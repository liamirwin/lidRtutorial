---
title: "Digital Terrain Models"
---

```{r, echo = FALSE}
library(rgl)

r3dDefaults <- rgl::r3dDefaults
m <- structure(c(0.921, -0.146, 0.362, 0, 0.386, 0.482, -0.787, 0, 
                -0.06, 0.864, 0.5, 0, 0, 0, 0, 1), .Dim = c(4L, 4L))
r3dDefaults$FOV <- 50
r3dDefaults$userMatrix <- m
r3dDefaults$zoom <- 0.75

knitr::opts_chunk$set(
  comment =  "#>", 
  collapse = TRUE,
  fig.align = "center")

rgl::setupKnitr(autoprint = TRUE)
```

## Relevant resources

[lidRbook section](https://r-lidar.github.io/lidRbook/dtm.html)

## Overview

This tutorial explores the creation of a Digital Terrain Model (DTM) from LiDAR data. It demonstrates two algorithms for DTM generation, ground point triangulation, and inverse-distance weighting. Additionally, the tutorial showcases DTM-based normalization and point-based normalization, accompanied by exercises for hands-on practice.

## DTM (Digital Terrain Model)

In this section, we'll generate a Digital Terrain Model (DTM) from LiDAR data using two different algorithms: `tin()` and `knnidw()`.

```{r clear_warnings, warnings = FALSE, message = FALSE}
# Clear environment and specific warnings
rm(list = ls(globalenv()))
options("rgdal_show_exportToProj4_warnings" = "none")

# Load libraries
library(lidR)
```

### Data Preprocessing

```{r dtm_data_preprocessing}
# Load LiDAR data and filter out non-ground points
las <- readLAS(files = "data/MixedEucaNat.laz", filter = "-set_withheld_flag 0")
```

Here, we load the LiDAR data and exclude non-ground points flagged with the withheld flag.

### Visualizing LiDAR Data

```{r dtm_visualize_data}
# Visualize the LiDAR data and ground points
plot(las)
```

We start by visualizing the entire LiDAR point cloud to get an initial overview.

```{r dtm_visualize_data_bg}
# Visualize the LiDAR data with ground points highlighted against a white background
plot(las, color = "Classification", bg = "white")
```

Visualizing the LiDAR data again, this time with a white background, helps distinguish ground points more effectively.

### Triangulation Algorithm

```{r dtm_triangulation}
# Generate a DTM using the TIN (Triangulated Irregular Network) algorithm
dtm_tin <- grid_terrain(las = las, res = 1, algorithm = tin())
```

We create a DTM using the TIN algorithm with a specified resolution.

### Visualizing DTM in 3D

```{r dtm_visualize_3d}
# Visualize the DTM in 3D
plot_dtm3d(dtm_tin)
```

To better understand the terrain, we visualize the generated DTM in a 3D plot.

### Visualizing DTM with LiDAR Data

```{r dtm_visualize_with_lidar}
# Visualize the LiDAR data with the overlaid DTM in 3D
x <- plot(las, bg = "white")
add_dtm3d(x, dtm_tin)
```

We overlay the DTM on the LiDAR data for a more comprehensive view of the terrain.

### Inverse-Distance Weighting Algorithm

```{r dtm_idw}
# Generate a DTM using the IDW (Inverse-Distance Weighting) algorithm
dtm_idw <- grid_terrain(las = las, res = 1, algorithm = knnidw())
```

Next, we generate a DTM using the IDW algorithm to compare results with the TIN-based DTM.

### Visualizing IDW-based DTM in 3D

```{r dtm_visualize_idw_3d}
# Visualize the IDW-based DTM in 3D
plot_dtm3d(dtm_idw)
```

We visualize the DTM generated using the IDW algorithm in a 3D plot.

## Normalization

In this section, we'll focus on height normalization of LiDAR data using both DTM-based and point-based normalization methods.

### DTM-based Normalization

```{r normalization_dtm}
# Normalize the LiDAR data using DTM-based normalization
nlas_dtm <- normalize_height(las = las, algorithm = dtm_tin)
```

We perform DTM-based normalization on the LiDAR data using the previously generated DTM.

### Visualizing Normalized LiDAR Data

```{r normalization_visualize}
# Visualize the normalized LiDAR data
plot(nlas_dtm, bg = "white")
```

We visualize the normalized LiDAR data, illustrating heights relative to the DTM.

### Filtering Ground Points

```{r normalization_filter_ground}
# Filter the normalized data to retain only ground points
gnd_dtm <- filter_ground(las = nlas_dtm)
```

We filter the normalized data to keep only the ground points.

### Visualizing Filtered Ground Points

```{r normalization_visualize_filtered_ground}
# Visualize the filtered ground points
plot(gnd_dtm, bg = "white")
```

We visualize the filtered ground points, focusing on the terrain after normalization.

### Histogram of Normalized Ground Points

```{r normalization_histogram}
# Plot the histogram of normalized ground points' height
hist(gnd_dtm$Z, breaks = seq(-1.5, 1.5, 0.05))
```

A histogram helps us understand the distribution of normalized ground points' height.

### DTM-based Normalization with TIN Algorithm

```{r normalization_dtm_tin}
# Normalize the LiDAR data using DTM-based normalization with TIN algorithm
nlas_tin <- normalize_height(las = las, algorithm = tin())
```

We perform DTM-based normalization on the LiDAR data using the TIN algorithm.

### Visualizing Normalized LiDAR Data with TIN

```{r normalization_visualize_tin}
# Visualize the normalized LiDAR data using the TIN algorithm
plot(nlas_tin, bg = "white")
```

We visualize the normalized LiDAR data using the TIN algorithm, showing heights relative to the DTM.

### Filtering Ground Points (TIN-based)

```{r normalization_filter_ground_tin}
# Filter the normalized data (TIN-based) to retain only ground points
gnd_tin <- filter_ground(las = nlas_tin)
```

We filter the normalized data (TIN-based) to keep only the ground points.

### Visualizing Filtered Ground Points (TIN-based)

```{r normalization_visualize_filtered_ground_tin}
# Visualize the filtered ground points after TIN-based normalization
plot(gnd_tin, bg = "white")
```

We visualize the filtered ground points after TIN-based normalization, focusing on the terrain.

### Histogram of Normalized Ground Points (

TIN-based)

```{r normalization_histogram_tin}
# Plot the histogram of normalized ground points' height after TIN-based normalization
hist(gnd_tin$Z, breaks = seq(-1.5, 1.5, 0.05))
```

A histogram illustrates the distribution of normalized ground points' height after TIN-based normalization.

## Exercises

#### E1.

Plot and compare these two normalized point-clouds. Why do they look different? Fix that. Hint: `filter`.

```r
# Load and visualize nlas1 and nlas2
las1 = readLAS("data/MixedEucaNat.laz", filter = "-set_withheld_flag 0")
nlas1 = normalize_height(las1, tin())
nlas2 = readLAS("data/MixedEucaNat_normalized.laz", filter = "-set_withheld_flag 0")
plot(nlas1)
plot(nlas2)
```

#### E2.

Clip a plot somewhere in `MixedEucaNat.laz` (the non-normalized file).

#### E3.

Compute a DTM for this plot. Which method are you choosing and why?

#### E4.

Compute a DSM (digital surface model). Hint: Look back to how you made a CHM.

#### E5.

Normalize the plot.

#### E6. 

Compute a CHM.

#### E7.

Compute some metrics of interest in this plot with `cloud_metrics()`.

## Conclusion

This tutorial covered the creation of Digital Terrain Models (DTMs) from LiDAR data using different algorithms and explored height normalization techniques. The exercises provided hands-on opportunities to apply these concepts, enhancing understanding and practical skills.
